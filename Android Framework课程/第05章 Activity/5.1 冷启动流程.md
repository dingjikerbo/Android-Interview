# Activity启动

startActivity
--> startActivityAsUser
--> mStackSupervisor.startActivityMayWait

```
final int startActivityMayWait(IApplicationThread caller, int callingUid,) {
        // Don't modify the client's object!
        intent = new Intent(intent);

        // Collect information about the target of the Intent.
        ActivityInfo aInfo = resolveActivity(intent, resolvedType, );

        int res = startActivityLocked(caller, );

        if (outResult != null) {
            outResult.result = res;
            mWaitingActivityLaunched.add(outResult);
            do {
                try {
                    mService.wait();
                } catch (InterruptedException e) {
                }
            } while (!outResult.timeout && outResult.who == null);
        }

        return res;
    }
}
```

我们看startActivityLocked，

```
final int startActivityLocked(IApplicationThread caller,) {
    ActivityRecord r = new ActivityRecord(mService, );

    err = startActivityUncheckedLocked(r, sourceRecord, );

    return err;
}
```

这个mPendingActivityLaunches是表示因为禁止appSwitch而pending的Activity列表，我们暂不考虑禁止appSwitch的情况，这里这个列表就为空。因此，这里直接执行startActivityUncheckedLocked，

```
final int startActivityUncheckedLocked(final ActivityRecord r, ) {
    // 找一个合适的栈
    ......

    // 判断目标Activity是否在栈顶，如果是需要判断是创建一个新的activity还是调用onNewIntent，这里notTop为null。

    ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(notTop);

    // 又是一堆处理task的逻辑

    targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, );
    
    return ActivityManager.START_SUCCESS;
}
```

这里找到targetStack之后，在该栈中执行startActivityLocked函数，这里面insertTaskAtTop给Activity所属的task加到当前ActivityStack的mTaskHistory的末尾，这个相当于栈顶，之后启动的时候首先看这个task。并且task内部给这个Activity也加到mActivies的末尾，这个也相当于栈顶。

```
final void startActivityLocked(ActivityRecord r, boolean newTask,) {
    ......
    task = r.task;

    if (!r.mLaunchTaskBehind && (taskForIdLocked(taskId) == null || newTask)) {
        insertTaskAtTop(rTask, r);
    }

    // Slot the activity into the history stack and proceed
    task.addActivityToTop(r);
    task.setFrontOfTask();

    r.putInHistory();

    if (doResume) {
        mStackSupervisor.resumeTopActivitiesLocked(this, r, options);
    }
}
```

这儿呢targetStack是frontStack，所以直接执行resumeTopActivityLocked
```
boolean resumeTopActivitiesLocked(ActivityStack targetStack, ) {
    if (targetStack == null) {
        targetStack = mFocusedStack;
    }
    // Do targetStack first.
    boolean result = false;
    if (isFrontStack(targetStack)) {
        result = targetStack.resumeTopActivityLocked(target, targetOptions);
    }

    for (int displayNdx = mActivityDisplays.size() - 1; displayNdx >= 0; --displayNdx) {
        final ArrayList<ActivityStack> stacks = mActivityDisplays.valueAt(displayNdx).mStacks;
        for (int stackNdx = stacks.size() - 1; stackNdx >= 0; --stackNdx) {
            final ActivityStack stack = stacks.get(stackNdx);
            if (stack == targetStack) {
                // Already started above.
                continue;
            }
            if (isFrontStack(stack)) {
                stack.resumeTopActivityLocked(null);
            }
        }
    }
    return result;
}
```

这儿prev是null，因为是点击桌面图标启动的，

```
final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) {
    result = resumeTopActivityInnerLocked(prev, options);
```


对冷启动来说，这儿的mResumedActivity为null，所以没执行startPausingLocked，
```
private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ) {
    // Find the first activity that is not finishing.
    final ActivityRecord next = topRunningActivityLocked(null);

    if (mResumedActivity != null) {
        startPausingLocked(userLeaving, false, true, dontWaitForPause);
    }

    mStackSupervisor.startSpecificActivityLocked(next, true, true);

    return true;
}
```

```
void startSpecificActivityLocked(ActivityRecord r,
        boolean andResume, boolean checkConfig) {
    ProcessRecord app = mService.getProcessRecordLocked(r.processName,
            r.info.applicationInfo.uid, true);

    if (app != null && app.thread != null) {
        realStartActivityLocked(r, app, andResume, checkConfig);
        return;
    }

    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,
            "activity", r.intent.getComponent(), false, false, true);
}
```

进程启动之后，会启动pending的Activity，这里拿到前台stack，然后从里面的最近的TaskRecord里找到栈顶的Activity，如果进程名称匹配的上，就启动它。

```
boolean attachApplicationLocked(ProcessRecord app) throws RemoteException {
    final String processName = app.processName;
    boolean didSomething = false;

    for (int stackNdx = stacks.size() - 1; stackNdx >= 0; --stackNdx) {
        final ActivityStack stack = stacks.get(stackNdx);
        if (!isFrontStack(stack)) {
            continue;
        }
        ActivityRecord hr = stack.topRunningActivityLocked(null);
       
        if (hr.app == null&& processName.equals(hr.processName)) {
            realStartActivityLocked(hr, app, true, true);
        }
    }

    return didSomething;
}
```

# View
我们看下view的draw是谁调用的，是ViewRootImpl里面调的，

```
private boolean drawSoftware(Surface surface, AttachInfo attachInfo, ) {

    // Draw with software renderer.
    final Canvas canvas;

    final int left = dirty.left;
    final int top = dirty.top;
    final int right = dirty.right;
    final int bottom = dirty.bottom;

    canvas = mSurface.lockCanvas(dirty);

    mView.draw(canvas);
 
    surface.unlockCanvasAndPost(canvas);
    return true;
}
```

这个函数是ViewRootImpl里面的draw函数调用的, 如下，这个mSurface是哪里来的呢？是ViewRootImpl在构造的时候就创建好的。但是这个是个空壳啊，什么时候真正创建surface的呢？

```
private void draw(boolean fullRedrawNeeded) {
    Surface surface = mSurface;

    drawSoftware(surface, mAttachInfo, xOffset, yOffset, );

    if (animating) {
        mFullRedrawNeeded = true;
        scheduleTraversals();
    }
}
```

ViewRootimpl里面调用mWindowSession.relayout函数去申请surface，最后一个参数就带上了这个mSurface，这个surface是实现了parcelable的，所以可以跨进程传递，这个就调到了WMS的relayoutWindow这个函数里，

```
public int relayoutWindow(Session session, IWindow client, ) {
    ......
    SurfaceControl surfaceControl = winAnimator.createSurfaceLocked();
    if (surfaceControl != null) {
        outSurface.copyFrom(surfaceControl);
    }
    ......
}
```

这个SurfaceControl里包着一个surface，

```
SurfaceControl createSurfaceLocked() {
    if (mSurfaceControl == null) {
        mSurfaceControl = new SurfaceControl();
        // Start a new transaction and apply position & offset.
        SurfaceControl.openTransaction();
        // initialize SurfaceControl
    }
    return mSurfaceControl;
}
```

这个surfaceControl是谁创建的呢？

```
public SurfaceControl(SurfaceSession session,) {
    mName = name;
    mNativeObject = nativeCreate(session, name, w, h, format, flags);
}
```

这个就到了native层，这先拿到SurfaceComposerClient，然后调用他的createSurface，这个android_view_SurfaceSession_getClient函数是干嘛的呢，是从SurfaceSession的Java对象里有个mNativeClient，这个是保存了native层的SurfaceComposerClient。这个SurfaceSession是什么创建的呢？是WMS里面addWindow的时候会先给这个window创建一个WindowState，然后调用他的attach函数，这里面就会创建一个SurfaceSession的Java对象，然后在native层创建一个SurfaceComposerClient对象，保存到Java层。

```
static jlong nativeCreate(JNIEnv* env, jclass clazz, jobject sessionObj,) {
    sp<SurfaceComposerClient> client(android_view_SurfaceSession_getClient());
    sp<SurfaceControl> surface = client->createSurface(
            String8(name.c_str()), w, h, format, flags);
    return reinterpret_cast<jlong>(surface.get());
}
```

现在调用SurfaceComposerClient的createSurface，实现在SurfaceFlinger中，

```
sp<SurfaceControl> SurfaceComposerClient::createSurface() {
    sp<SurfaceControl> sur;
    if (mStatus == NO_ERROR) {
        sp<IBinder> handle;
        sp<IGraphicBufferProducer> gbp;
        status_t err = mClient->createSurface(name, w, h, format, flags,
                &handle, &gbp);
        sur = new SurfaceControl(this, handle, gbp);
    }
    return sur;
}
```

这个mClient是个什么东西，是SurfaceComposerClient，这个对象刚创建的时候，会调用createConnection，这个请求发到了SurfaceFlinger，返回一个ISurfaceComposerClient接口,这个的实现是Client.cpp。之后就会用这个接口调用createSurface，上面这个函数本地还创建了一个native层的surfaceControl对象。这个SurfaceControl里有个handle和GraphicBufferProducer，

```
void SurfaceComposerClient::onFirstRef() {
    sp<ISurfaceComposer> sm(ComposerService::getComposerService());
    if (sm != 0) {
        sp<ISurfaceComposerClient> conn = sm->createConnection();
        if (conn != 0) {
            mClient = conn;
            mStatus = NO_ERROR;
        }
    }
}
```

再看mClient的createSurface是怎么调的，这个是封装了一个消息丢到消息队列里，然后同步等待，这里调用了SurfaceFlinger的createLayer函数，
```
status_t Client::createSurface(
        const String8& name,
        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,
        sp<IBinder>* handle,
        sp<IGraphicBufferProducer>* gbp)
{
    /*
     * createSurface must be called from the GL thread so that it can
     * have access to the GL context.
     */

    class MessageCreateLayer : public MessageBase {
        SurfaceFlinger* flinger;
        Client* client;
        sp<IBinder>* handle;
        sp<IGraphicBufferProducer>* gbp;
        status_t result;
        const String8& name;
        uint32_t w, h;
        PixelFormat format;
        uint32_t flags;
    public:
        MessageCreateLayer(SurfaceFlinger* flinger,
                const String8& name, Client* client,
                uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,
                sp<IBinder>* handle,
                sp<IGraphicBufferProducer>* gbp)
            : flinger(flinger), client(client),
              handle(handle), gbp(gbp),
              name(name), w(w), h(h), format(format), flags(flags) {
        }
        status_t getResult() const { return result; }
        virtual bool handler() {
            result = flinger->createLayer(name, client, w, h, format, flags,
                    handle, gbp);
            return true;
        }
    };

    sp<MessageBase> msg = new MessageCreateLayer(mFlinger.get(),
            name, this, w, h, format, flags, handle, gbp);
    mFlinger->postMessageSync(msg);
    return static_cast<MessageCreateLayer*>( msg.get() )->getResult();
}
```

这个createLayer干了什么呢？

```
status_t SurfaceFlinger::createLayer(
        const String8& name,
        const sp<Client>& client,
        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,
        sp<IBinder>* handle, sp<IGraphicBufferProducer>* gbp) {
    status_t result = NO_ERROR;

    sp<Layer> layer;

    switch (flags & ISurfaceComposerClient::eFXSurfaceMask) {
        case ISurfaceComposerClient::eFXSurfaceNormal:
            result = createNormalLayer(client,
                    name, w, h, flags, format,
                    handle, gbp, &layer);
            break;
        case ISurfaceComposerClient::eFXSurfaceDim:
            result = createDimLayer(client,
                    name, w, h, flags,
                    handle, gbp, &layer);
            break;
        default:
            result = BAD_VALUE;
            break;
    }

    if (result != NO_ERROR) {
        return result;
    }

    result = addClientLayer(client, *handle, *gbp, layer);
    if (result != NO_ERROR) {
        return result;
    }

    setTransactionFlags(eTransactionNeeded);
    return result;
}

status_t SurfaceFlinger::createNormalLayer(const sp<Client>& client,
        const String8& name, uint32_t w, uint32_t h, uint32_t flags, PixelFormat& format,
        sp<IBinder>* handle, sp<IGraphicBufferProducer>* gbp, sp<Layer>* outLayer)
{
    // initialize the surfaces
    switch (format) {
    case PIXEL_FORMAT_TRANSPARENT:
    case PIXEL_FORMAT_TRANSLUCENT:
        format = PIXEL_FORMAT_RGBA_8888;
        break;
    case PIXEL_FORMAT_OPAQUE:
        format = PIXEL_FORMAT_RGBX_8888;
        break;
    }

    *outLayer = new Layer(this, client, name, w, h, flags);
    status_t err = (*outLayer)->setBuffers(w, h, format, flags);
    if (err == NO_ERROR) {
        *handle = (*outLayer)->getHandle();
        *gbp = (*outLayer)->getProducer();
    }

    ALOGE_IF(err, "createNormalLayer() failed (%s)", strerror(-err));
    return err;
}
```

我们看到创建layer之后，就可以获取producer了。

看一下开机动画，

```
service bootanim /system/bin/bootanimation
    class core
    user graphics
    group graphics audio
    disabled
    oneshot
```

```
int main() {
    sp<ProcessState> proc(ProcessState::self());
    ProcessState::self()->startThreadPool();

    // create the boot animation object
    sp<BootAnimation> boot = new BootAnimation();

    IPCThreadState::self()->joinThreadPool();
    return 0;
}
```

这里面关键类是BootAnimation，这里创建了一个SurfaceComposerClient对象，这个对象是每个应用程序和SurfaceFlinger之间的纽带。下面onFirstRef中会调run函数，这个BootAnimation继承了Thread，所以这里会创建一个线程，run的时候会先执行readyToRun，然后执行threadloop函数。

```
BootAnimation::BootAnimation() : Thread(false), mZip(NULL)
{
    mSession = new SurfaceComposerClient();
}

void BootAnimation::onFirstRef() {
    run("BootAnimation", PRIORITY_DISPLAY);
}
```

readyToRun干了什么呢？首先createSurface，这个函数我们上面讲了，会返回一个SurfaceControl，里面的graphicBufferProducer和handle都准备好了。

```
status_t BootAnimation::readyToRun() {
    // create the native surface
    sp<SurfaceControl> control = session()->createSurface();
    sp<Surface> s = control->getSurface();
    // 下面是初始化OpenGL环境
    return NO_ERROR;
}
```

我们再来看threadloop，这里面就是opengl绘制了。

应用程序可以通过调用createSurface创建多个layer，


# 看startActivity过程
```
public int startActivity(IBinder whoThread, String callingPackage,) {
    return mStackSupervisor.startActivityMayWait(appThread, -1,);
}
```

```
final int startActivityMayWait(IApplicationThread caller, int callingUid,) {
    
    // Don't modify the client's object!
    intent = new Intent(intent);

    // Collect information about the target of the Intent.
    ActivityInfo aInfo =
            resolveActivity(intent, resolvedType, startFlags, profilerInfo, userId);

    ActivityContainer container = (ActivityContainer)iContainer;
    synchronized (mService) {
        final ActivityStack stack;
        if (container == null || container.mStack.isOnHomeDisplay()) {
            stack = mFocusedStack;
        } else {
            stack = container.mStack;
        }


        int res = startActivityLocked(caller, intent, resolvedType, aInfo,
                voiceSession, voiceInteractor, resultTo, resultWho,
                requestCode, callingPid, callingUid, callingPackage,
                realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,
                componentSpecified, null, container, inTask);


        if (outResult != null) {
            outResult.result = res;
            if (res == ActivityManager.START_SUCCESS) {
                mWaitingActivityLaunched.add(outResult);
                do {
                    try {
                        mService.wait();
                    } catch (InterruptedException e) {
                    }
                } while (!outResult.timeout && outResult.who == null);
            } else if (res == ActivityManager.START_TASK_TO_FRONT) {
                ActivityRecord r = stack.topRunningActivityLocked(null);
                if (r.nowVisible && r.state == RESUMED) {
                    outResult.timeout = false;
                    outResult.who = new ComponentName(r.info.packageName, r.info.name);
                    outResult.totalTime = 0;
                    outResult.thisTime = 0;
                } else {
                    outResult.thisTime = SystemClock.uptimeMillis();
                    mWaitingActivityVisible.add(outResult);
                    do {
                        try {
                            mService.wait();
                        } catch (InterruptedException e) {
                        }
                    } while (!outResult.timeout && outResult.who == null);
                }
            }
        }

        return res;
    }
}
```