

ContentProvider启动，是在应用启动的时候，attachApplication，

```
private final boolean attachApplicationLocked(IApplicationThread thread,) {
    ...
    List<ProviderInfo> providers = generateApplicationProvidersLocked(app);

    if (providers != null && checkAppInLaunchingProvidersLocked(app)) {
        Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);
        msg.obj = app;
        mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);
    }

    ...
}
```


下面这个函数是从PKMS中查询到当前应用中AndroidManifest里注册的provider。
然后对每个provider创建一个ContentProviderRecord，存到mProviderMap里。
这个map是根据componentName来找到provider record的。此外，ProcessRecord里也
存了一份provider record。
```
private final List<ProviderInfo> generateApplicationProvidersLocked(ProcessRecord app) {
    List<ProviderInfo> providers = null;
  
    ParceledListSlice<ProviderInfo> slice = AppGlobals.getPackageManager().
        queryContentProviders(app.processName, app.uid,
                STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
    providers = slice.getList();

    int N = providers.size();

    for (int i=0; i<N; i++) {
        ProviderInfo cpi = providers.get(i);

        ComponentName comp = new ComponentName(cpi.packageName, cpi.name);
        ContentProviderRecord cpr = mProviderMap.getProviderByClass(comp, userId);
        if (cpr == null) {
            cpr = new ContentProviderRecord(this, cpi, app.info, comp, singleton);
            mProviderMap.putProviderByClass(comp, cpr);
        }
    
        app.pubProviders.put(cpi.name, cpr);
    }

    return providers;
}
```

回到attachApplication，这个checkAppInLaunchingProvidersLocked，还有一个mLaunchingProviders，这个是有其它应用等着用这个provider呢，如果有进程匹配上了，表示可以分发这个provider了。所以这里开始超时计时，这个超时是10s。

```
private final boolean attachApplicationLocked(IApplicationThread thread,) {
    ...
    List<ProviderInfo> providers = generateApplicationProvidersLocked(app);

    if (providers != null && checkAppInLaunchingProvidersLocked(app)) {
        Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);
        msg.obj = app;
        mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);
    }

    ...
}

boolean checkAppInLaunchingProvidersLocked(ProcessRecord app) {
    for (int i = mLaunchingProviders.size() - 1; i >= 0; i--) {
        ContentProviderRecord cpr = mLaunchingProviders.get(i);
        if (cpr.launchingApp == app) {
            return true;
        }
    }
    return false;
}
```

那什么时候开始publish provider的呢？是在接下来的bindApplication。这里会开始installContentProviders，这个ProviderInfo是Parcelable的，所以可以跨进程从AMS传过来。

```
private void handleBindApplication(AppBindData data) {
    mBoundApplication = data;
    mConfiguration = new Configuration(data.config);
    mCompatConfiguration = new Configuration(data.config);

    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);

    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);
    
    mInstrumentation = new Instrumentation();

    Application app = data.info.makeApplication(...);
    mInitialApplication = app;
   
    List<ProviderInfo> providers = data.providers;
    if (providers != null) {
        installContentProviders(app, providers);
    }

    mInstrumentation.onCreate(data.instrumentationArgs);
    mInstrumentation.callApplicationOnCreate(app);
}
```


下面这个函数依次对ProviderInfo进行installProvider，最后给results publish给AMS。看来关键是installProvider，
```
private void installContentProviders(
            Context context, List<ProviderInfo> providers) {
        final ArrayList<IActivityManager.ContentProviderHolder> results =
            new ArrayList<IActivityManager.ContentProviderHolder>();

        for (ProviderInfo cpi : providers) {
            IActivityManager.ContentProviderHolder cph = installProvider(context, null, cpi,
                    false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/);
            if (cph != null) {
                cph.noReleaseNeeded = true;
                results.add(cph);
            }
        }

        ActivityManagerNative.getDefault().publishContentProviders(
                getApplicationThread(), results);
    }

```


看来，这里主要是创建Provider对象，ContentProvider里面有个binder对象，叫IContentProvider，这个对象是要丢给AMS的，这样AMS就可以调到provider内部了，这个attachInfo是设置context，并且调用onCreate的。应用端有一个和AMS端的provider record对应的provider client record。应用端有两个provider的map，一个是以component name为key，一个是以provider的binder为key。
```
private IActivityManager.ContentProviderHolder installProvider(Context context,
        IActivityManager.ContentProviderHolder holder, ProviderInfo info,
        boolean noisy, boolean noReleaseNeeded, boolean stable) {
    ContentProvider localProvider = null;
    IContentProvider provider;
    
    Context c = null;
    ApplicationInfo ai = info.applicationInfo;
    c = context;

    final java.lang.ClassLoader cl = c.getClassLoader();
    localProvider = (ContentProvider)cl.loadClass(info.name).newInstance();
    provider = localProvider.getIContentProvider();
    localProvider.attachInfo(c, info);

    IActivityManager.ContentProviderHolder retHolder;

    IBinder jBinder = provider.asBinder();
    ComponentName cname = new ComponentName(info.packageName, info.name);
    ProviderClientRecord pr = mLocalProvidersByName.get(cname);
    if (pr != null) {
        provider = pr.mProvider;
    } else {
        holder = new IActivityManager.ContentProviderHolder(info);
        holder.provider = provider;
        holder.noReleaseNeeded = true;
        pr = installProviderAuthoritiesLocked(provider, localProvider, holder);
        mLocalProviders.put(jBinder, pr);
        mLocalProvidersByName.put(cname, pr);
    }
    retHolder = pr.mHolder;

    return retHolder;
}
```


ContentProviderHolder是啥？这个IBinder是啥？奇怪，上面installProvider好像没设置connection，可能是在installProviderAuthoritiesLocked里面设置的？

```
public static class ContentProviderHolder implements Parcelable {
        public final ProviderInfo info;
        public IContentProvider provider;
        public IBinder connection;
        public boolean noReleaseNeeded;
}
```

原来应用端还有一个Provider的map，key是Providerkey。
```
private ProviderClientRecord installProviderAuthoritiesLocked(IContentProvider provider, ContentProvider localProvider,IActivityManager.ContentProviderHolder holder) 
{
    final String auths[] = holder.info.authority.split(";");
    final int userId = UserHandle.getUserId(holder.info.applicationInfo.uid);

    final ProviderClientRecord pcr = new ProviderClientRecord(
            auths, provider, localProvider, holder);
    for (String auth : auths) {
        final ProviderKey key = new ProviderKey(auth, userId);
        mProviderMap.put(key, pcr); 
    }
    return pcr;
}
```

还是没看到connection，不管了，看provider怎么publish到AMS的，这里给src里面的IContentProvider保存在AMS的ContentProviderRecord里面了，如果有超时就给停掉，然后对这个content provider调用notifyAll，难道有人在wait？

```
public final void publishContentProviders(IApplicationThread caller,
    List<ContentProviderHolder> providers) {

    final ProcessRecord r = getRecordForAppLocked(caller);

    final int N = providers.size();
    for (int i = 0; i < N; i++) {
        ContentProviderHolder src = providers.get(i);
        ContentProviderRecord dst = r.pubProviders.get(src.info.name);
       
        if (dst != null) {
            ComponentName comp = new ComponentName(dst.info.packageName, dst.info.name);
            mProviderMap.putProviderByClass(comp, dst);
            String names[] = dst.info.authority.split(";");
            for (int j = 0; j < names.length; j++) {
                mProviderMap.putProviderByName(names[j], dst);
            }

            int launchingCount = mLaunchingProviders.size();
            int j;
            boolean wasInLaunchingProviders = false;
            for (j = 0; j < launchingCount; j++) {
                if (mLaunchingProviders.get(j) == dst) {
                    mLaunchingProviders.remove(j);
                    wasInLaunchingProviders = true;
                    j--;
                    launchingCount--;
                }
            }
            if (wasInLaunchingProviders) {
                mHandler.removeMessages(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG, r);
            }
            dst.provider = src.provider;
            dst.proc = r;
            dst.notifyAll();
        }
    }
}
```

搜了一下，还真是有，在AMS的getContentProviderImpl里，谁调了她？有两个函数，一个getContentProvider，一个getContentProviderExternalUnchecked，咱们先看getContentProviderImpl干了什么？这个函数太长了，咱们先放着，先看getContentResolver，

contentResolver是contextImpl的构造函数里创建的，实现是ApplicationContentResolver，我们以insert为例，这里首先acquireProvider，拿到IContentProvider，然后调用insert，然后releaseProvider。

```
public final Uri insert(Uri url, ContentValues values) {
    IContentProvider provider = acquireProvider(url);
    Uri createdRow = provider.insert(mPackageName, url, values);
    releaseProvider(provider);
    return createdRow;
        
}
```

首先看uri前面是不是带content://，如果不是返回null。然后根据auth找到provider，这个acquireProvider的实现在ApplicationContentResolver里面，
```
public final IContentProvider acquireProvider(Uri uri) {
    if (!SCHEME_CONTENT.equals(uri.getScheme())) {
        return null;
    }
    final String auth = uri.getAuthority();
    if (auth != null) {
        return acquireProvider(mContext, auth);
    }
    return null;
}
```

这个mMainThread是ActivityThread，
```
@Override
protected IContentProvider acquireProvider(Context context, String auth) {
    return mMainThread.acquireProvider(context, ...);
}
```

首先调acquireExistingProvider查询本地已经有的provider，如果查到了直接返回。否则向AMS获取，然后调用installProvider，注意一下，这里的installProvider，AMS返回的holder里是带有provider的binder句柄的，直接拿来用就行了，然后给provider放到本地缓存里。
```
public final IContentProvider acquireProvider(
        Context c, String auth, int userId, boolean stable) {
    final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);
    if (provider != null) {
        return provider;
    }

    IActivityManager.ContentProviderHolder holder = null;
    
    holder = ActivityManagerNative.getDefault().getContentProvider(
                getApplicationThread(), auth, userId, stable);

    holder = installProvider(c, holder, holder.info,
            true /*noisy*/, holder.noReleaseNeeded, stable);
    return holder.provider;
}
```

再来看AMS的getContentProvider实现，

```
@Override
public final ContentProviderHolder getContentProvider(...) {
    return getContentProviderImpl(caller, name, null, stable, userId);
}
```

首先看provider是不是存在，通过判断providerRunning。
```
private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller, String name, IBinder token, boolean stable, int userId) {
    ContentProviderRecord cpr;
    ContentProviderConnection conn = null;
    ProviderInfo cpi = null;

    synchronized(this) {
        cpr = mProviderMap.getProviderByName(name, userId);
        boolean providerRunning = cpr != null;

        if (providerRunning) {
            cpi = cpr.info;

            // 该contentProvider是否能运行在调用者所在进程
            // 条件是{contentProvider的multiprocess是true，并且调用者进程和provider在一个进程}，
            // 或者provider和调用者所在进程是一个uid
            if (r != null && cpr.canRunHere(r)) {
                ContentProviderHolder holder = cpr.newHolder(null);
                holder.provider = null;
                return holder;
            }

            conn = incProviderCountLocked(r, cpr, token, stable);
        }

        // 如果provider不存在，就
        if (!providerRunning) {
            cpi = AppGlobals.getPackageManager().resolveContentProvider(name,);
            cpi.applicationInfo = getAppInfoForUser(cpi.applicationInfo, );

            ComponentName comp = new ComponentName(cpi.packageName, cpi.name);
            cpr = mProviderMap.getProviderByClass(comp, userId);
           
            final boolean firstClass = cpr == null;
            ApplicationInfo ai = AppGlobals.getPackageManager().
                            getApplicationInfo();
                    
            ai = getAppInfoForUser(ai, userId);
            cpr = new ContentProviderRecord(this, cpi, ai, );

            final int N = mLaunchingProviders.size();
            int i;

            // 从launchingProviders里查找有不有该record，
            for (i = 0; i < N; i++) {
                if (mLaunchingProviders.get(i) == cpr) {
                    break;
                }
            }

            // 如果没有，并且进程没启动的话，那就启动它
            // 如果进程启动了，那就scheduleInstallProvider让应用发布provider
            if (i >= N) {
                AppGlobals.getPackageManager().setPackageStoppedState(
                            cpr.appInfo.packageName, false, userId);
                
                ProcessRecord proc = getProcessRecordLocked(
                        cpi.processName, cpr.appInfo.uid, false);
                if (proc != null && proc.thread != null) {
            
                    if (!proc.pubProviders.containsKey(cpi.name)) {
                        proc.pubProviders.put(cpi.name, cpr);
                        proc.thread.scheduleInstallProvider(cpi);
                    }
                } else {
                    proc = startProcessLocked(cpi.processName,
                            cpr.appInfo, false, 0, "content provider",
                            new ComponentName(cpi.applicationInfo.packageName,
                                    cpi.name), false, false, false);
                }
                cpr.launchingApp = proc;
                mLaunchingProviders.add(cpr);
            }

            mProviderMap.putProviderByClass(comp, cpr);
            mProviderMap.putProviderByName(name, cpr);
            conn = incProviderCountLocked(r, cpr, token, stable);
        }
    }

    while (cpr.provider == null) {
        if (conn != null) {
            conn.waiting = true;
        }
        cpr.wait();
    }
    return cpr != null ? cpr.newHolder(conn) : null;
}
```