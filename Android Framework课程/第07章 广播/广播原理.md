
这个fromMsg一般是false，

```
final void processNextBroadcast(boolean fromMsg) {
    synchronized(mService) {
        BroadcastRecord r;

        // First, deliver any non-serialized broadcasts right away.
        while (mParallelBroadcasts.size() > 0) {
            r = mParallelBroadcasts.remove(0);
            r.dispatchTime = SystemClock.uptimeMillis();
            r.dispatchClockTime = System.currentTimeMillis();
            final int N = r.receivers.size();
          
            for (int i=0; i<N; i++) {
                Object target = r.receivers.get(i);
                deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false);
            }
        }

        if (mPendingBroadcast != null) {
            return;
        }

        boolean looped = false;
        
        do {
            if (mOrderedBroadcasts.size() == 0) {
                return;
            }
            r = mOrderedBroadcasts.get(0);
            boolean forceReceive = false;

            int numReceivers = r.receivers.size();
            if (r.dispatchTime > 0) {
                long now = SystemClock.uptimeMillis();
                if ((numReceivers > 0) &&
                        (now > r.dispatchTime + (2*mTimeoutPeriod*numReceivers))) {
                    broadcastTimeoutLocked(false); // forcibly finish this broadcast
                    forceReceive = true;
                    r.state = BroadcastRecord.IDLE;
                }
            }

            // 如果没超时，并且状态不是IDLE，表示正在处理中，那就直接返回，等着他处理
            if (r.state != BroadcastRecord.IDLE) {
                return;
            }

            // 如果当前是IDLE，并且处理完了或者超时了，就停止当前record分发，准备处理下一个record
            if (r.receivers == null || r.nextReceiver >= numReceivers
                    || r.resultAbort || forceReceive) {
                cancelBroadcastTimeoutLocked();

                mOrderedBroadcasts.remove(0);
                r = null;
                looped = true;
                continue;
            }

            // 走到这表示当前record还没分发完，并且当前状态是IDLE。那就退出while循环，
            // 开始处理当前record吧
        } while (r == null);

        // Get the next receiver...
        int recIdx = r.nextReceiver++;

        // 这个receiverTime表示当前receiver的开始处理时间
        r.receiverTime = SystemClock.uptimeMillis();
        if (recIdx == 0) {
            // 这个dispatchTime记录着当前record的第一个receiver处理的时间
            r.dispatchTime = r.receiverTime;
            r.dispatchClockTime = System.currentTimeMillis();
        }
        // 这个表示为false，表示还没开启超时呢
        if (! mPendingBroadcastTimeoutMessage) {
            long timeoutTime = r.receiverTime + mTimeoutPeriod;
            setBroadcastTimeoutLocked(timeoutTime);
        }

        final Object nextReceiver = r.receivers.get(recIdx);

        // BroadcastFilter表示是动态广播，直接分发就好了，设为IDLE，分发完准备下一次分发
        // 所以这里先直接返回。
        if (nextReceiver instanceof BroadcastFilter) {
            BroadcastFilter filter = (BroadcastFilter)nextReceiver;
        
            deliverToRegisteredReceiverLocked(r, filter, r.ordered);

            // 这个if条件很奇怪，可能是deliver过程发生异常了，所以给r.receiver设为null
            // 这时候不管了，分发下一条
            if (r.receiver == null || !r.ordered) {
                // The receiver has already finished, so schedule to
                // process the next one.
                r.state = BroadcastRecord.IDLE;
                scheduleBroadcastsLocked();
            }

            return;
        }

        // 下面是处理串行化广播里的静态广播

        ResolveInfo info = (ResolveInfo)nextReceiver;

        // 给状态置为APP_RECEIVE
        r.state = BroadcastRecord.APP_RECEIVE;
        r.curReceiver = info.activityInfo;

        // 看进程启动没有
        ProcessRecord app = mService.getProcessRecordLocked(targetProcess,
                info.activityInfo.applicationInfo.uid, false);

        // 进程启动了，直接分发
        if (app != null && app.thread != null) {
            processCurBroadcastLocked(r, app);
            return;
        }

        // 先启动进程，给当前record设为pending，等进程启动后再处理
        r.curApp = mService.startProcessLocked(...);

        mPendingBroadcast = r;
        mPendingBroadcastRecvIndex = recIdx;
    }
}
```

先说这个mPendingBroadcast，在上面这个函数里，当待onReceive的进程没启动时，就启动进程，同时设置这个mPendingBroadcast。那什么给他设为null呢？就是应用进程启动好了之后，attachApplication的时候，会调用这个sendPendingBroadcastsLocked，这里就会给他设为null，并且调用
processCurBroadcastLocked来处理。所以上面判断如果mPendingBroadcast非空，则表示进程正在启动过程中，还没有到处理pendingBroadcast而已，所以就退出，等待处理pendingBroadcast就好了。注意这个pendingBroadcast只可能是静态广播的，所以才涉及进程的启动。动态广播如果进程没启动，怎么能注册呢？


咱们看看processCurBroadcastLocked的实现，

```
public boolean sendPendingBroadcastsLocked(ProcessRecord app) {
        boolean didSomething = false;
        final BroadcastRecord br = mPendingBroadcast;
        if (br != null && br.curApp.pid == app.pid) {
            mPendingBroadcast = null;
            processCurBroadcastLocked(br, app);
            didSomething = true;
        }
        return didSomething;
    }
```


这里很简单，就是调用应用层的scheduleReceiver，注意这是静态广播，动态广播调的是应用层的scheduleRegisteredReceiver函数，不一样的，没有生命周期。但是静态广播是有生命周期的。
```
private final void processCurBroadcastLocked(BroadcastRecord r,
        ProcessRecord app) throws RemoteException {
    r.receiver = app.thread.asBinder();
    r.curApp = app;
    app.curReceiver = r;

    app.thread.scheduleReceiver(new Intent(r.intent), r.curReceiver,
                mService.compatibilityInfoForPackageLocked(r.curReceiver.applicationInfo),
                r.resultCode, r.resultData, r.resultExtras, r.ordered, r.userId,
                app.repProcState);
}
```


应用层在主线程处理静态广播，要注意，这里会设置pendingResult，然后最后的时候会调用data.finish函数，
```
private void handleReceiver(ReceiverData data) {
    LoadedApk packageInfo = getPackageInfoNoCheck(
            data.info.applicationInfo, data.compatInfo);

    IActivityManager mgr = ActivityManagerNative.getDefault();

    BroadcastReceiver receiver;

    java.lang.ClassLoader cl = packageInfo.getClassLoader();
    data.intent.setExtrasClassLoader(cl);
    data.intent.prepareToEnterProcess();
    data.setExtrasClassLoader(cl);
    receiver = (BroadcastReceiver)cl.loadClass(component).newInstance();

    Application app = packageInfo.makeApplication(false, mInstrumentation);

    ContextImpl context = (ContextImpl)app.getBaseContext();
    sCurrentBroadcastIntent.set(data.intent);
    receiver.setPendingResult(data);
    receiver.onReceive(context.getReceiverRestrictedContext(),
            data.intent);

    if (receiver.getPendingResult() != null) {
        data.finish();
    }
}
```

看下finish是干嘛，注意应用端处理完动态广播，一样会发这个finish，
```
public final void finish() {
    ......
    sendFinished(mgr);      
}
```

这个sendFinished是干嘛的，因为静态广播是串行化分发的，所以这里分发完了要通知AMS，好去分发下一个,

```
public void sendFinished(IActivityManager am) {
    am.finishReceiver(mToken, mResultCode, mResultData, mResultExtras,
                mAbortBroadcast, mFlags);
```

看下AMS里的finishReceiver处理，这个getMatchingOrderedReceiver是看当前BroadcastRecord正在处理的receiver是不是刚好是这个who，如果不是就返回null。如果是就调finishReceiverLocked，如果这个函数返回true，就去处理当前record的下一个receiver。

```
public void finishReceiver(IBinder who, int resultCode, String resultData,
            Bundle resultExtras, boolean resultAbort, int flags) {
    boolean doNext = false;
    BroadcastRecord r;

    BroadcastQueue queue = mBgBroadcastQueue;
    r = queue.getMatchingOrderedReceiver(who);
    if (r != null) {
        doNext = r.queue.finishReceiverLocked(r, resultCode,
            resultData, resultExtras, resultAbort, true);
    }

    if (doNext) {
        r.queue.processNextBroadcast(false);
    }
```

BroadcastQueue的finishReceiverLocked什么时候返回true呢？看下这个函数实现，这里先给record的状态保存为state，然后给record的状态设为idle，这样下一次processNextBroadcast时就能继续往下处理了。返回的时候判断state，其实如果processNextBroadcast中处理到静态广播的时候会给状态置为APP_RECEIVE，如果处理到串行的动态广播会给状态置为CALL_DONE_RECEIVE，所以这里返回true。注意，如果是处理普通的动态广播，状态就一直是IDLE。所以上面的finishReceiver就不会processNextBroadcast。

```
public boolean finishReceiverLocked(BroadcastRecord r, int resultCode,
            String resultData, Bundle resultExtras, boolean resultAbort, boolean waitForServices) {
    final int state = r.state;
    final ActivityInfo receiver = r.curReceiver;
    r.state = BroadcastRecord.IDLE;

    r.receiver = null;
    r.intent.setComponent(null);
    if (r.curApp != null && r.curApp.curReceiver == r) {
        r.curApp.curReceiver = null;
    }
    if (r.curFilter != null) {
        r.curFilter.receiverList.curBroadcast = null;
    }
    r.curFilter = null;
    r.curReceiver = null;
    r.curApp = null;
    mPendingBroadcast = null;

    r.resultCode = resultCode;
    r.resultData = resultData;
    r.resultExtras = resultExtras;
   

    return state == BroadcastRecord.APP_RECEIVE
            || state == BroadcastRecord.CALL_DONE_RECEIVE;
}
```


看下动态广播的处理，

```
public void performReceive(Intent intent, int resultCode, String data,
        Bundle extras, boolean ordered, boolean sticky, int sendingUser) {
    LoadedApk.ReceiverDispatcher rd = mDispatcher.get();
    if (rd != null) {
        rd.performReceive(intent, resultCode, data, extras,
                ordered, sticky, sendingUser);
    }
}
```

回到上面的processNextBroadcast函数，如果有序的BroadcastRecord都处理完了，就直接返回。否则取出第一个来处理，先看超时，这个mTimeoutPerios是60s中，够长的了。先看broadcastTimeoutLocked的实现，

```
do {
    if (mOrderedBroadcasts.size() == 0) {
        return;
    }
    r = mOrderedBroadcasts.get(0);
    boolean forceReceive = false;

    int numReceivers = r.receivers.size() : 0;
    if (r.dispatchTime > 0) {
        long now = SystemClock.uptimeMillis();
        if ((numReceivers > 0) &&
                (now > r.dispatchTime + (2*mTimeoutPeriod*numReceivers))) {
            broadcastTimeoutLocked(false); // forcibly finish this broadcast
            forceReceive = true;
            r.state = BroadcastRecord.IDLE;
        }
    }

    if (r.state != BroadcastRecord.IDLE) {
        return;
    }

    if (r.receivers == null || r.nextReceiver >= numReceivers
            || r.resultAbort || forceReceive) {
        cancelBroadcastTimeoutLocked();

        mOrderedBroadcasts.remove(0);
        r = null;
        continue;
    }
} while (r == null);
```

如果广播超时了，则强制结束这个广播，怎么强制结束的呢？

这个receiverTime表示当前receiver超时的时间戳。nextReceiver表示下一个要处理的receiver的index。如果这个值小于等于0，表示这个BroadcastRecord已经全部处理完过了，所以都清空了，已经过时了，所以这里直接返回。如果mPendingBroadcast等于当前的BroadcastRecord，也要置为null，不让别人再等了。

```
final void broadcastTimeoutLocked(boolean fromMsg) {
    if (mOrderedBroadcasts.size() == 0) {
        return;
    }

    long now = SystemClock.uptimeMillis();
    BroadcastRecord r = mOrderedBroadcasts.get(0);

    r.receiverTime = now;
    r.anrCount++;

    // Current receiver has passed its expiration date.
    if (r.nextReceiver <= 0) {
        return;
    }

    ProcessRecord app = null;
    String anrMessage = null;

    Object curReceiver = r.receivers.get(r.nextReceiver-1);
   
    if (curReceiver instanceof BroadcastFilter) {
        BroadcastFilter bf = (BroadcastFilter)curReceiver;
        if (bf.receiverList.pid != 0
                && bf.receiverList.pid != ActivityManagerService.MY_PID) {
            synchronized (mService.mPidsSelfLocked) {
                app = mService.mPidsSelfLocked.get(
                        bf.receiverList.pid);
            }
        }
    } else {
        app = r.curApp;
    }

    if (mPendingBroadcast == r) {
        mPendingBroadcast = null;
    }

    // Move on to the next receiver.
    finishReceiverLocked(r, r.resultCode, r.resultData,
            r.resultExtras, r.resultAbort, false);
    scheduleBroadcastsLocked();
}
```

看下finishReceiverLocked的实现，这里给BroadcastRecord状态置为IDLE，表示可以调度下一个receiver了。r.receiver设为null表示当前没有receiver在处理。这里面就是复位BroadcastRecord的状态，该清的清，准备处理下一条。而上面这个函数的scheduleBroadcastsLocked，其实就是调processNextBroadcast。

```
public boolean finishReceiverLocked(BroadcastRecord r, int resultCode,) {
    final int state = r.state;
    final ActivityInfo receiver = r.curReceiver;
    r.state = BroadcastRecord.IDLE;
    r.receiver = null;

    if (r.curApp != null && r.curApp.curReceiver == r) {
        r.curApp.curReceiver = null;
    }
    if (r.curFilter != null) {
        r.curFilter.receiverList.curBroadcast = null;
    }
    r.curFilter = null;
    r.curReceiver = null;
    r.curApp = null;
    mPendingBroadcast = null;

    r.resultCode = resultCode;
    r.resultData = resultData;
    r.resultExtras = resultExtras;
}
```
