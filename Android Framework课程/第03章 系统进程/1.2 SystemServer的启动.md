# SystemServer的启动

Zygote的Java世界一个重要步骤就是startSystemServer函数，

这里面先
Zygote.forkSystemServer启动SystemServer进程，

然后执行
handleSystemServerProcess

这里面主要动作是：
执行RuntimeInit类的zygoteInit函数

```
// RuntimeInit.java
void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) {
        commonInit();
        nativeZygoteInit();
        applicationInit(targetSdkVersion, argv, classLoader);
    }
```

commonInit做一些常规的初始化，比如异常捕获、时区之类的，暂时先不关注。

nativeZygoteInit实现在AndroidRuntime.cpp中，这里的gCurRuntime就是Zygote初始化时设置的AppRuntime，继承自AndroidRuntime，一些回调函数都是在这个子类里实现的。

```
// AndroidRuntime.cpp
static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)
{
    gCurRuntime->onZygoteInit();
}
```

AppRuntime定义在app_main.cpp里，可见onZygoteInit的主要工作就是启动Binder线程池。

```
virtual void onZygoteInit() {
    sp<ProcessState> proc = ProcessState::self();
    proc->startThreadPool();
}
```

再来看applicationInit，主要是执行这个类里的main函数，这个类就是SystemServer.java了

```
void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) {
    ......
    invokeStaticMain(args.startClass, args.startArgs, classLoader);
}
```

SystemServer类中的main函数很简单，执行了run函数，

```
// SystemServer.java
public static void main(String[] args) {
    new SystemServer().run();
}
```

这个run函数有点长，干了不少活。

```
private void run() {
    ......
    Looper.prepareMainLooper();

    // Initialize native services.
    System.loadLibrary("android_servers");
    ......
    // Create the system service manager.
    mSystemServiceManager = new SystemServiceManager(mSystemContext);
    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);

    // Start services.
    try {
        startBootstrapServices();
        startCoreServices();
        startOtherServices();
    } catch (Throwable ex) {
        throw ex;
    }

    // Loop forever.
    Looper.loop();
    throw new RuntimeException("Main thread loop unexpectedly exited");
}
```

这里面开头prepareLooper，结尾looper.loop，中间就是各种准备过程了。包括加载android_servers库，这个库源码是在frameworks/base/services下，里面有很多目录，我们可以通过Android.mk就能了解整个so的大致结构，我们重点看core目录，这个so的onLoad函数在onload.cpp里，

```
extern "C" jint JNI_OnLoad(JavaVM* vm, void* /* reserved */)
{
    JNIEnv* env = NULL;
    jint result = -1;

    if (vm->GetEnv((void**) &env, JNI_VERSION_1_4) != JNI_OK) {
        ALOGE("GetEnv failed!");
        return result;
    }
    ALOG_ASSERT(env, "Could not retrieve the env!");

    register_android_server_ActivityManagerService(env);
    register_android_server_PowerManagerService(env);
    register_android_server_SerialService(env);
    register_android_server_InputApplicationHandle(env);
    register_android_server_InputWindowHandle(env);
    register_android_server_InputManager(env);
    register_android_server_LightsService(env);
    register_android_server_AlarmManagerService(env);
    register_android_server_UsbDeviceManager(env);
    register_android_server_UsbMidiDevice(env);
    register_android_server_UsbHostManager(env);
    register_android_server_VibratorService(env);
    register_android_server_SystemServer(env);
    register_android_server_location_GpsLocationProvider(env);
    register_android_server_location_FlpHardwareProvider(env);
    register_android_server_connectivity_Vpn(env);
    register_android_server_AssetAtlasService(env);
    register_android_server_ConsumerIrService(env);
    register_android_server_BatteryStatsService(env);
    register_android_server_hdmi_HdmiCecController(env);
    register_android_server_tv_TvInputHal(env);
    register_android_server_PersistentDataBlockService(env);
    register_android_server_Watchdog(env);


    return JNI_VERSION_1_4;
}
```

这是个标准的JNI_OnLoad的实现，主要是注册各个系统服务的JNI函数。回到SystemServer的run函数，在加载完android_servers的so库后，创建SystemServiceManager，然后添加到LocalServices里，这个LocalServices里有个ArrayMap，缓存了所有的SystemService接口，有点类似ServiceManager，但是这里的Service都是进程内的，无需考虑IPC。

这个SystemServiceManager有个SystemService列表，缓存了当前已启动的service。它启动某个service的过程其实就是创建该service对应的类对象，给该对象加到一个列表里，然后执行该对象的onStart回调。SystemServiceManager里除了startService外，还有一个重要函数就是startBootPhase，这个函数的作用是对于所有已经启动的service，执行他们的onBootPhase回调，告诉他们当前的启动进度。

我们回到SystemServer的run函数，在初始化完SystemServiceManager之后，就是启动各类service了，service很多哈，我们见过的，没见过的都有，这里就不care了，不过注意启动service的过程还包括在ServiceManager中添加服务。最后的重头戏是ActivityManagerService的systemReady函数，传入了一个大大的Runnable，在AMS的systemReady中会启动桌面。

# 额外内容
1，信号，进程如果异常则如何？
2，watchDog？

# 总结
1. Zygote中在Java世界执行startSystemServer
2. 先通过native层fork SystemServer进程，然后调用RuntimeInit.java的zygoteInit函数，里面会启动binder线程池，然后执行SystemServer.java类的main函数，里面会加载android_servers的so库，里面是一些系统服务的native层，然后就是启动各类系统服务了，启动完之后，最后启动桌面，然后进入looper循环。

我们最重要的是搞清楚一个问题，既然系统服务大部分都在SystemServer中，比如说AMS, PMS, WMS之类的，而且这里进入了loop循环。那么应用进程是怎么和SystemServer中的AMS, PMS, WMS之类的通信的？换句话说，SystemServer是怎么从looper.loop中唤醒的。其实SystemServer不用在主线程唤醒，只要别退出main就行，那别的子线程就还在。我们要先了解一下linux进程的main入口函数是主线程，在主线程开了很多子线程，只要main没退出，那么子线程就还在。如果主线程调用pthread_exit，那么子线程就可以不退出。我们自己搞一个应用服务，里面也可以有很多service。

SystemServer中除了这个主线程在loop中休眠外，还有一堆binder线程，当收到IPC时，就会调起binder call，但这都不是唤醒主线程。除非拿到了主线程的looper，然后发消息。注意，binder线程不能被长期占用，如果有些服务需要有自己的looper的话，那就单开一个线程。

我们可以注意到AMS里的ipc调用，都会锁住整个AMS
