

在AMS的systemReady中，一个重要步骤就是

startHomeActivityLocked
然后
mStackSupervisor.resumeTopActivitiesLocked();

```    
boolean startHomeActivityLocked(int userId, String reason) {
    Intent intent = getHomeIntent();
    ActivityInfo aInfo =
        resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);
    if (aInfo != null) {
        intent.setComponent(new ComponentName(
                aInfo.applicationInfo.packageName, aInfo.name));
        // Don't do this if the home app is currently being
        // instrumented.
        aInfo = new ActivityInfo(aInfo);
        aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId);
        ProcessRecord app = getProcessRecordLocked(aInfo.processName,
                aInfo.applicationInfo.uid, true);
        if (app == null || app.instrumentationClass == null) {
            intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
            mStackSupervisor.startHomeActivity(intent, aInfo, reason);
        }
    }

    return true;
}
```

这个getHomeIntent是啥，
```
Intent getHomeIntent() {
    Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null);
    intent.setComponent(mTopComponent);
    if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        intent.addCategory(Intent.CATEGORY_HOME);
    }
    return intent;
}
```

假设应用运行在非工厂测试模式，那么intent就是CATEGORY_HOME, 这个mTopAction是ACTION_MAIN,

这个launcher运行在哪个进程呢？我们看startHomeActivity的实现，
```
void startHomeActivity(Intent intent, ActivityInfo aInfo, String reason) {
    ......
    startActivityLocked(...);
}

final int startActivityLocked(IApplicationThread caller,) {
        int err = ActivityManager.START_SUCCESS;

        ProcessRecord callerApp = null;
  
        final int userId = aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;


        ActivityRecord sourceRecord = null;
        ActivityRecord resultRecord = null;
        

        final int launchFlags = intent.getFlags();

        if ((launchFlags & Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 && sourceRecord != null) {
            // Transfer the result target from the source activity to the new
            // one being started, including any failures.
            if (requestCode >= 0) {
                ActivityOptions.abort(options);
                return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;
            }
            resultRecord = sourceRecord.resultTo;
            if (resultRecord != null && !resultRecord.isInStackLocked()) {
                resultRecord = null;
            }
            resultWho = sourceRecord.resultWho;
            requestCode = sourceRecord.requestCode;
            sourceRecord.resultTo = null;
            if (resultRecord != null) {
                resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);
            }
            if (sourceRecord.launchedFromUid == callingUid) {
                // The new activity is being launched from the same uid as the previous
                // activity in the flow, and asking to forward its result back to the
                // previous.  In this case the activity is serving as a trampoline between
                // the two, so we also want to update its launchedFromPackage to be the
                // same as the previous activity.  Note that this is safe, since we know
                // these two packages come from the same uid; the caller could just as
                // well have supplied that same package name itself.  This specifially
                // deals with the case of an intent picker/chooser being launched in the app
                // flow to redirect to an activity picked by the user, where we want the final
                // activity to consider it to have been launched by the previous app activity.
                callingPackage = sourceRecord.launchedFromPackage;
            }
        }



        ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage,
                intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho,
                requestCode, componentSpecified, voiceSession != null, this, container, options);



        err = startActivityUncheckedLocked();
        return err;
    }
```



在Launcher3中，我们看他的AndroidManifest，找到入口Activity，名叫Launcher，在LauncherModel这个类里，调了loadAllAppsByBatch去加载所有应用的入口Activity，调的是

```
List<LauncherActivityInfo> apps = null;

while (i < N && !mStopped) {
    if (i == 0) {
        apps = mLauncherApps.getActivityList(null, user);
        ......
}
```

而这个getActivityList是哪呢？看下面的函数，

```
public List<LauncherActivityInfo> getActivityList(String packageName, UserHandle user) {
    List<ResolveInfo> activities = null;

    activities = mService.getLauncherActivities(packageName, user);
    ArrayList<LauncherActivityInfo> lais = new ArrayList<>();

    for (int i = 0; i < activities.size(); i++) {
        ResolveInfo ri = activities.get(i);
        LauncherActivityInfo lai = new LauncherActivityInfo(mContext, ri,);
        lais.add(lai);
    }
    return lais;
}
```

关键是getLauncherActivities，这个mService是什么呢？其实是LauncherAppService，这个也是SystemServer里的系统服务，binder的实现在LauncherAppsImpl中，这个getLauncherActivities是从PMS中查询CATEGORY_LAUNCHER和ACTION_MAIN的intent, 然后返回解析结果，

```
public List<ResolveInfo> getLauncherActivities(String packageName, ) {
    final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
    mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
    mainIntent.setPackage(packageName);

    try {
        List<ResolveInfo> apps = mPm.queryIntentActivitiesAsUser(mainIntent, 0 /* flags */, user.getIdentifier());
        return apps;
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
```

这个mPm是ApplicationPackageManager，继承于PackageManager，这里的queryIntentActivitiesAsUser调的是PMS服务的queryIntentActivities

然后Launcher里有个bindAllApplications，用于刷新图标的icon，图标的adapter是AllAppsGridAdapter，是AllAppsContainerView里面设置的，图标点击函数在Launcher类里实现的，这个Launcher自己实现了View.OnClickListener，

```
public void onClick(View v) {
    Object tag = v.getTag();
    if (tag instanceof ShortcutInfo) {
        onClickAppShortcut(v);
    } else if (tag instanceof FolderInfo) {
        if (v instanceof FolderIcon) {
            onClickFolderIcon(v);
        }
    } else if (v == mAllAppsButton) {
        onClickAllAppsButton(v);
    } else if (tag instanceof AppInfo) {
        startAppShortcutOrInfoActivity(v);
    } else if (tag instanceof LauncherAppWidgetInfo) {
        if (v instanceof PendingAppWidgetHostView) {
            onClickPendingWidget((PendingAppWidgetHostView) v);
        }
    }
}
```

如果点击了app的图标，触发下面的函数，
```
protected void onClickAppShortcut(final View v) {
    Object tag = v.getTag();

    // Open shortcut
    final ShortcutInfo shortcut = (ShortcutInfo) tag;
    final Intent intent = shortcut.intent;

    // Start activities
    startAppShortcutOrInfoActivity(v);
}
```

看下startAppShortcutOrInfoActivity干嘛的，调startActivitySafely，

```
void startAppShortcutOrInfoActivity(View v) {
        Object tag = v.getTag();
        final ShortcutInfo shortcut;
        final Intent intent;
        if (tag instanceof ShortcutInfo) {
            shortcut = (ShortcutInfo) tag;
            intent = shortcut.intent;
            int[] pos = new int[2];
            v.getLocationOnScreen(pos);
            intent.setSourceBounds(new Rect(pos[0], pos[1],
                    pos[0] + v.getWidth(), pos[1] + v.getHeight()));

        }

        boolean success = startActivitySafely(v, intent, tag);
    }
```

看看这个startActivitySafely，

```
private boolean startActivity(View v, Intent intent, Object tag) {
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    startActivity(intent, optsBundle);
    return true;
}
```