搜索startProcessLocked，

四大组件，
ActiveServices.bringUpServiceLocked
ActivityManagerService.getContentProviderImpl
ActivityStackSupervisor.startSpecificActivityLocked
BroadcastQueue.processNextBroadcast

先看Activity,

```
void startSpecificActivityLocked(ActivityRecord r, ...) {
    ProcessRecord app = mService.getProcessRecordLocked(r.processName, ...);
    if (app != null && app.thread != null) {
        realStartActivityLocked(r, app, andResume, checkConfig);
        return;
    }
    mService.startProcessLocked(r.processName, ...);
}
```

有个疑问，如果启动了进程，但是还没来得及attachApplication到AMS，就又有一个启动这个进程的请求，会怎么办呢？


再看service,

```
private final String bringUpServiceLocked(ServiceRecord r, ...) {
    app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);
   
    if (app != null && app.thread != null) {
        realStartServiceLocked(r, app, execInFg);
        return null;
    }
    if (app == null) {
        app=mAm.startProcessLocked(procName, ...);
    }
    if (!mPendingServices.contains(r)) {
        mPendingServices.add(r);
    }
    return null;
}
```


再看下provider，
```
ContentProviderHolder getContentProviderImpl(...) {
    ProcessRecord proc = getProcessRecordLocked(
            cpi.processName, cpr.appInfo.uid, false);
    if (proc != null && proc.thread != null) {
        // 
    } else {
        proc = startProcessLocked(cpi.processName, ...);
    }
    ......
}
```

最后看下广播，

```
final void processNextBroadcast(boolean fromMsg) {
    ProcessRecord app = mService.getProcessRecordLocked(...);
    if (app != null && app.thread != null) {
        processCurBroadcastLocked(r, app);
        return;
    }

    mService.startProcessLocked(targetProcess, ...);

    mPendingBroadcast = r;
    mPendingBroadcastRecvIndex = recIdx;
}
```

```
private final void startProcessLocked(ProcessRecord app, ......) {
    Process.start(...);
}
```